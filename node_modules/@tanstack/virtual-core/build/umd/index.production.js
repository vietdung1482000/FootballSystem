/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).VirtualCore={})}(this,(function(e){"use strict";function t(e,t,s){let n,i=[];return()=>{let o;s.key&&null!=s.debug&&s.debug()&&(o=Date.now());const l=e();if(!(l.length!==i.length||l.some(((e,t)=>i[t]!==e))))return n;let r;if(i=l,s.key&&null!=s.debug&&s.debug()&&(r=Date.now()),n=t(...l),null==s||null==s.onChange||s.onChange(n),s.key&&null!=s.debug&&s.debug()){const e=Math.round(100*(Date.now()-o))/100,t=Math.round(100*(Date.now()-r))/100,n=t/16,i=(e,t)=>{for(e=String(e);e.length<t;)e=" "+e;return e};console.info(`%c⏱ ${i(t,5)} /${i(e,5)} ms`,`\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0,Math.min(120-120*n,120))}deg 100% 31%);`,null==s?void 0:s.key)}return n}}const s=e=>e,n=e=>{const t=Math.max(e.startIndex-e.overscan,0),s=Math.min(e.endIndex+e.overscan,e.count-1),n=[];for(let e=t;e<=s;e++)n.push(e);return n},i={element:["scrollLeft","scrollTop"],window:["scrollX","scrollY"]},o=e=>(t,s)=>{if(!t.scrollElement)return;const n=i[e][0],o=i[e][1];let l=t.scrollElement[n],r=t.scrollElement[o];const a=()=>{const e=t.scrollElement[t.options.horizontal?n:o];s(Math.max(0,e-t.options.scrollMargin))};a();const h=e=>{const s=e.currentTarget,i=s[n],h=s[o];(t.options.horizontal?l-i:r-h)&&a(),l=i,r=h};return t.scrollElement.addEventListener("scroll",h,{capture:!1,passive:!0}),()=>{t.scrollElement.removeEventListener("scroll",h)}},l=o("element"),r=o("window"),a=(e,t)=>Math.round(e.getBoundingClientRect()[t.options.horizontal?"width":"height"]);e.Virtualizer=class{constructor(e){var i=this;this.unsubs=[],this.scrollElement=null,this.isScrolling=!1,this.isScrollingTimeoutId=null,this.measurementsCache=[],this.itemMeasurementsCache={},this.pendingMeasuredCacheIndexes=[],this.scrollAdjustments=0,this.measureElementCache={},this.pendingScrollToIndexCallback=null,this.getResizeObserver=(()=>{let e=null;return()=>e||("undefined"!=typeof ResizeObserver?e=new ResizeObserver((e=>{e.forEach((e=>{this._measureElement(e.target,!1)}))})):null)})(),this.range={startIndex:0,endIndex:0},this.setOptions=e=>{Object.entries(e).forEach((t=>{let[s,n]=t;void 0===n&&delete e[s]})),this.options={debug:!1,initialOffset:0,overscan:1,paddingStart:0,paddingEnd:0,scrollPaddingStart:0,scrollPaddingEnd:0,horizontal:!1,getItemKey:s,rangeExtractor:n,onChange:()=>{},measureElement:a,initialRect:{width:0,height:0},scrollMargin:0,scrollingDelay:150,indexAttribute:"data-index",...e}},this.notify=()=>{var e,t;null==(e=(t=this.options).onChange)||e.call(t,this)},this.cleanup=()=>{this.unsubs.filter(Boolean).forEach((e=>e())),this.unsubs=[],this.scrollElement=null},this._didMount=()=>{const e=this.getResizeObserver();return Object.values(this.measureElementCache).forEach((t=>null==e?void 0:e.observe(t))),()=>{null==e||e.disconnect(),this.cleanup()}},this._willUpdate=()=>{var e;null==(e=this.pendingScrollToIndexCallback)||e.call(this);const t=this.options.getScrollElement();this.scrollElement!==t?(this.cleanup(),this.scrollElement=t,this._scrollToOffset(this.scrollOffset,{adjustments:void 0,behavior:void 0,sync:!0}),this.unsubs.push(this.options.observeElementRect(this,(e=>{this.scrollRect=e,this.calculateRange()}))),this.unsubs.push(this.options.observeElementOffset(this,(e=>{null!==this.isScrollingTimeoutId&&(clearTimeout(this.isScrollingTimeoutId),this.isScrollingTimeoutId=null);const t=e=>{this.isScrolling!==e&&(this.isScrolling=e,this.notify())};this.scrollAdjustments=0,this.scrollOffset!==e&&(this.scrollOffset=e,t(!0)),this.calculateRange(),this.isScrollingTimeoutId=setTimeout((()=>{this.isScrollingTimeoutId=null,t(!1)}),this.options.scrollingDelay)})))):this.isScrolling||this.calculateRange()},this.getSize=()=>this.scrollRect[this.options.horizontal?"width":"height"],this.getMeasurements=t((()=>[this.options.count,this.options.paddingStart,this.options.getItemKey,this.itemMeasurementsCache]),((e,t,s,n)=>{const i=this.pendingMeasuredCacheIndexes.length>0?Math.min(...this.pendingMeasuredCacheIndexes):0;this.pendingMeasuredCacheIndexes=[];const o=this.measurementsCache.slice(0,i);for(let l=i;l<e;l++){const e=s(l),i=n[e],r=o[l-1]?o[l-1].end:t,a="number"==typeof i?i:this.options.estimateSize(l),h=r+a;o[l]={index:l,start:r,size:a,end:h,key:e}}return this.measurementsCache=o,o}),{key:!1,debug:()=>this.options.debug}),this.calculateRange=t((()=>[this.getMeasurements(),this.getSize(),this.scrollOffset]),((e,t,s)=>{const n=function(e){let{measurements:t,outerSize:s,scrollOffset:n}=e;const i=t.length-1,o=((e,t,s,n)=>{for(;e<=t;){const i=(e+t)/2|0,o=s(i);if(o<n)e=i+1;else{if(!(o>n))return i;t=i-1}}return e>0?e-1:0})(0,i,(e=>t[e].start),n);let l=o;for(;l<i&&t[l].end<n+s;)l++;return{startIndex:o,endIndex:l}}({measurements:e,outerSize:t,scrollOffset:s});return n.startIndex===this.range.startIndex&&n.endIndex===this.range.endIndex||(this.range=n,this.notify()),this.range}),{key:!1,debug:()=>this.options.debug}),this.getIndexes=t((()=>[this.options.rangeExtractor,this.range,this.options.overscan,this.options.count]),((e,t,s,n)=>e({...t,overscan:s,count:n})),{key:!1,debug:()=>this.options.debug}),this.indexFromElement=e=>{const t=this.options.indexAttribute,s=e.getAttribute(t);return s?parseInt(s,10):(console.warn(`Missing attribute name '${t}={index}' on measured element.`),-1)},this._measureElement=(e,t)=>{const s=this.indexFromElement(e),n=this.measurementsCache[s];if(!n)return;const i=this.measureElementCache[n.key],o=this.getResizeObserver();if(!e.isConnected)return void(i&&(null==o||o.unobserve(i),delete this.measureElementCache[n.key]));i&&i===e||(i&&(null==o||o.unobserve(i)),this.measureElementCache[n.key]=e,null==o||o.observe(e));const l=this.options.measureElement(e,this),r=l-(this.itemMeasurementsCache[n.key]??n.size);0!==r&&(n.start<this.scrollOffset&&this.isScrolling&&this._scrollToOffset(this.scrollOffset,{adjustments:this.scrollAdjustments+=r,behavior:void 0,sync:!1}),this.pendingMeasuredCacheIndexes.push(s),this.itemMeasurementsCache={...this.itemMeasurementsCache,[n.key]:l},this.notify())},this.measureElement=e=>{e&&this._measureElement(e,!0)},this.getVirtualItems=t((()=>[this.getIndexes(),this.getMeasurements()]),((e,t)=>{const s=[];for(let n=0,i=e.length;n<i;n++){const i=t[e[n]];s.push(i)}return s}),{key:!1,debug:()=>this.options.debug}),this.scrollToOffset=function(e,t){let{align:s="start",behavior:n}=void 0===t?{}:t;const o=i.scrollOffset,l=i.getSize();"auto"===s&&(s=e<=o?"start":e>=o+l?"end":"start");const r={adjustments:void 0,behavior:n,sync:!1};"start"===s?i._scrollToOffset(e,r):"end"===s?i._scrollToOffset(e-l,r):"center"===s&&i._scrollToOffset(e-l/2,r)},this.scrollToIndex=function(e,t){let{align:s="auto",...n}=void 0===t?{}:t;i.pendingScrollToIndexCallback=null;const o=i.getMeasurements(),l=i.scrollOffset,r=i.getSize(),{count:a}=i.options,h=o[Math.max(0,Math.min(e,a-1))];if(!h)return;if("auto"===s)if(h.end>=l+r-i.options.scrollPaddingEnd)s="end";else{if(!(h.start<=l+i.options.scrollPaddingStart))return;s="start"}const c="end"===s?h.end+i.options.scrollPaddingEnd:h.start-i.options.scrollPaddingStart;i.scrollToOffset(c,{align:s,...n});if(Object.keys(i.measureElementCache).length>0){const t=()=>"number"==typeof i.itemMeasurementsCache[i.options.getItemKey(e)];t()||(i.pendingScrollToIndexCallback=()=>{t()&&(i.pendingScrollToIndexCallback=null,i.scrollToIndex(e,{align:s,...n}))})}},this.getTotalSize=()=>{var e;return((null==(e=this.getMeasurements()[this.options.count-1])?void 0:e.end)||this.options.paddingStart)+this.options.paddingEnd},this._scrollToOffset=(e,t)=>{let{adjustments:s,behavior:n,sync:i}=t;this.options.scrollToFn(e,{behavior:n,sync:i,adjustments:s},this)},this.measure=()=>{this.itemMeasurementsCache={},this.notify()},this.setOptions(e),this.scrollRect=this.options.initialRect,this.scrollOffset=this.options.initialOffset,this.calculateRange()}},e.defaultKeyExtractor=s,e.defaultRangeExtractor=n,e.elementScroll=(e,t,s)=>{var n;let{adjustments:i,behavior:o,sync:l}=t;const r=(l?e:e+s.options.scrollMargin)+(i??0);null==(n=s.scrollElement)||null==n.scrollTo||n.scrollTo({[s.options.horizontal?"left":"top"]:r,behavior:o})},e.measureElement=a,e.memo=t,e.observeElementOffset=l,e.observeElementRect=(e,t)=>{const s=new ResizeObserver((e=>{var s,n;t({width:null==(s=e[0])?void 0:s.contentRect.width,height:null==(n=e[0])?void 0:n.contentRect.height})}));if(e.scrollElement)return t(e.scrollElement.getBoundingClientRect()),s.observe(e.scrollElement),()=>{s.unobserve(e.scrollElement)}},e.observeWindowOffset=r,e.observeWindowRect=(e,t)=>{const s=((e,t)=>{let s={height:-1,width:-1};return n=>{(e.options.horizontal?n.width!==s.width:n.height!==s.height)&&t(n),s=n}})(e,t),n=()=>s({width:e.scrollElement.innerWidth,height:e.scrollElement.innerHeight});if(e.scrollElement)return n(),e.scrollElement.addEventListener("resize",n,{capture:!1,passive:!0}),()=>{e.scrollElement.removeEventListener("resize",n)}},e.windowScroll=(e,t,s)=>{var n;let{adjustments:i,behavior:o,sync:l}=t;const r=(l?e:e+s.options.scrollMargin)+(i??0);null==(n=s.scrollElement)||null==n.scrollTo||n.scrollTo({[s.options.horizontal?"left":"top"]:r,behavior:o})},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.production.js.map
