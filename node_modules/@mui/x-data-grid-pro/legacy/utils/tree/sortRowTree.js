import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
export var sortRowTree = function sortRowTree(params) {
  var rowIds = params.rowIds,
      rowTree = params.rowTree,
      disableChildrenSorting = params.disableChildrenSorting,
      sortRowList = params.sortRowList;
  var sortedRows = []; // Group the rows by parent

  var groupedByParentRows = new Map([[null, {
    body: [],
    footer: null
  }]]);

  for (var i = 0; i < rowIds.length; i += 1) {
    var rowId = rowIds[i];
    var node = rowTree[rowId];
    var group = groupedByParentRows.get(node.parent);

    if (!group) {
      group = {
        body: [],
        footer: null
      };
      groupedByParentRows.set(node.parent, group);
    }

    if (node.position === 'footer') {
      group.footer = node;
    } else {
      group.body.push(node);
    }
  } // Apply the sorting to each list of children


  var sortedGroupedByParentRows = new Map();
  groupedByParentRows.forEach(function (group, parent) {
    if (group.body.length === 0) {
      sortedGroupedByParentRows.set(parent, []);
    } else {
      var groupSortedRows;
      var depth = group.body[0].depth;

      if (depth > 0 && disableChildrenSorting || !sortRowList) {
        groupSortedRows = group.body.map(function (row) {
          return row.id;
        });
      } else {
        groupSortedRows = sortRowList(group.body);
      }

      if (group.footer != null) {
        groupSortedRows.push(group.footer.id);
      }

      sortedGroupedByParentRows.set(parent, groupSortedRows);
    }
  }); // Flatten the sorted lists to have children just after their parent

  var insertRowListIntoSortedRows = function insertRowListIntoSortedRows(startIndex, rowList) {
    sortedRows = [].concat(_toConsumableArray(sortedRows.slice(0, startIndex)), _toConsumableArray(rowList), _toConsumableArray(sortedRows.slice(startIndex)));
    var treeSize = 0;
    rowList.forEach(function (rowId) {
      treeSize += 1;
      var children = sortedGroupedByParentRows.get(rowId);

      if (children != null && children.length) {
        var subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);
        treeSize += subTreeSize;
      }
    });
    return treeSize;
  };

  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(null));
  return sortedRows;
};