import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';
export function addPinnedRow(_ref) {
  var _groupingParams$addit;

  var groupingParams = _ref.groupingParams,
      rowModel = _ref.rowModel,
      rowId = _ref.rowId,
      position = _ref.position,
      apiRef = _ref.apiRef;

  var idRowsLookup = _extends({}, groupingParams.idRowsLookup);

  var tree = _extends({}, groupingParams.tree); // TODO: warn if id is already present in `props.rows`


  idRowsLookup[rowId] = rowModel; // Do not push it to ids list so that pagination is not affected by pinned rows
  // ids.push(rowId);

  tree[rowId] = {
    id: rowId,
    isAutoGenerated: false,
    parent: null,
    depth: 0,
    groupingKey: null,
    groupingField: null,
    isPinned: true
  };
  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = _extends({}, rowModel);
  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;
  var previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};
  var newPinnedRow = {
    id: rowId,
    model: rowModel
  };
  return _extends({}, groupingParams, {
    idRowsLookup: idRowsLookup,
    tree: tree,
    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
      pinnedRows: _extends({}, previousPinnedRows, _defineProperty({}, position, [].concat(_toConsumableArray(previousPinnedRows[position] || []), [newPinnedRow])))
    })
  });
}
export var useGridRowPinningPreProcessors = function useGridRowPinningPreProcessors(apiRef) {
  var addPinnedRows = React.useCallback(function (groupingParams) {
    var _pinnedRowsCache$topI, _pinnedRowsCache$bott;

    var pinnedRowsCache = apiRef.current.unstable_caches.pinnedRows || {};

    var newGroupingParams = _extends({}, groupingParams, {
      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
        // reset pinned rows state
        pinnedRows: {}
      })
    });

    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(function (rowId) {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId: rowId,
        position: 'top',
        apiRef: apiRef
      });
    });
    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(function (rowId) {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId: rowId,
        position: 'bottom',
        apiRef: apiRef
      });
    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from `ids`

    newGroupingParams.ids = newGroupingParams.ids.filter(function (rowId) {
      if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].isPinned) {
        return false;
      }

      return true;
    });
    return newGroupingParams;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);
};